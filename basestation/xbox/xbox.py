"""
Contains an abstraction of an Xbox Controller.
"""

from basestation.base_station import BaseStation
from basestation.util.exception_handling import *

import pygame
import threading
import enum
import time


class Direction(enum.Enum):
    """
    A Direction Enum for readability.
    """
    FORWARD = object()
    RIGHT_FORWARD = object()
    BACKWARD = object()
    LEFT_FORWARD = object()
    STOP = object()


class Xbox(object):
    """
    An instance of Xbox is an abstraction to an Xbox Controller connected to
    the device running the BaseStation. The instance listens to inputs from
    the Xbox Controller, parses them, and forwards them to the associated
    MiniBot.
    """

    max_motor_pow = 100.

    def __init__(self, xbox_id: int, vbot_name: str):
        """
        Initializes an Xbox Controller x with `x.get_id() == xbox_id`
        associated to VirtualBot v with `v.get_name() == vbot_name`.

        Args:
            xbox_id (int): The ID of the Xbox Controller.
            vbot_name (str): The name of the VirtualBot to associate this
                Xbox Controller with.

        Raises:
            ValueError: If there does not exist a VirtualBot v with
            `v.get_name() == vbot_name`.
        """
        self.__joystick = pygame.joystick.Joystick(xbox_id)
        self.__joystick.init()
        self.__assoc_vbot = BaseStation().get_bot_manager().\
            get_bot_by_name(vbot_name)

        if self.__assoc_vbot is None:
            self.__del__()
            raise ValueError(vbot_name + " does not exist")

        self.__xbox_listener = threading.Thread(target=self.__listen)
        self.__xbox_listener.start()
        return

    def __del__(self):
        """
        Deletes this instance of Xbox interface to the controller.
        """
        self.__joystick.quit()
        self.__xbox_listener.join()
        return

    def get_xbox_id(self) -> int:
        """
        Returns the ID of the Xbox Controller.
        """
        return self.__joystick.get_id()

    def get_xbox_name(self) -> str:
        """
        Returns the name of the associated VirtualBot.
        """
        return self.__joystick.get_name()

    def set_assoc_bot(self, vbot_name: str) -> bool:
        """
        Returns True if the VirtualBot was successfully associated to this
        Xbox Controller.

        Args:
            vbot_name (str): Name of the VirtualBot to associate this Xbox
                Controller.
        """
        self.__assoc_vbot = BaseStation().get_bot_manager().\
            get_bot_by_name(vbot_name)

        return self.__assoc_vbot is None

    def __listen(self):
        """
        Listens to the inputs from the Xbox Controller, and passes to
        appropriate functions for parsing different triggers.

        Raises:
            RuntimeError: If listening failed, and the Xbox Controller's
                inputs couldn't be read.
        """
        try:
            while True:
                pygame.event.get()
                dpad_val = self.__joystick.get_hat(0)

                # take y values of the thumbs
                # for some weird reason, pushing up the thumbs on Xbox produces
                # negative values
                left_thumb_val = -self.__joystick.get_axis(1)
                right_thumb_val = -self.__joystick.get_axis(3)
                if dpad_val != (0, 0):
                    # dpad is pressed
                    self.__dpad_parse(dpad_val)

                elif abs(left_thumb_val) > .1 or abs(right_thumb_val) > .1:
                    # thumbs are triggered
                    self.__thumbs_parse(left_thumb_val, right_thumb_val)

                else:
                    # very slight disturbance in joystick saw as dead zone
                    self.__thumbs_parse(0., 0.)
                time.sleep(0.1)     # minimum reaction time of humans is 100ms

        except RuntimeError as e:
            msg = "Unable to get input from Xbox with ID = "\
                  + str(self.get_xbox_id())
            log_exn_info(e, msg=msg)

    def __dpad_parse(self, dpad_arr: tuple) -> bool:
        """
        Returns True if the dpad movement information in `dpad_arr` was
        successfully sent to the MiniBot.

        Args:
            dpad_arr (tuple): `dpad_arr[0]` is the Xbox trigger in the
                x-direction, and `dpad_arr[1]` is the Xbox trigger in the
                y-direction on the dpad. Should be generated by a getting the
                'hat' of the joystick.
        """
        x, y = dpad_arr[0], dpad_arr[1]
        if y > 0:
            return self.__move_bot_four_dir(Direction.FORWARD)
        elif y < 0:
            return self.__move_bot_four_dir(Direction.BACKWARD)
        elif x > 0:
            return self.__move_bot_four_dir(Direction.RIGHT_FORWARD)
        elif x < 0:
            return self.__move_bot_four_dir(Direction.LEFT_FORWARD)
        else:
            # x == 0 and y == 0
            return self.__move_bot_four_dir(Direction.STOP)

    def __thumbs_parse(self, left_thumb: float, right_thumb: float) -> bool:
        """
        Returns True if the thumb movement information in `left_thumb` and
        `right_thumb` was successfully sent to the MiniBot.

        Args:
            left_thumb (float): `-1 <= left_thumb <= 1`. Positive
                `left_thumb` means instructions to move the left wheel of the
                MiniBot forward.
            right_thumb (float): `-1 <= right_thumb <= 1`. Positive
                `right_thumb` means instructions to move the right wheel of the
                MiniBot forward.
        """
        return self.__move_bot(left_thumb * self.max_motor_pow, right_thumb *
                               self.max_motor_pow, 0., 0.)

    def __move_bot_four_dir(self, direction: Direction) -> bool:
        """
        Sends instructions to the MiniBot to move in `direction` by
        specifying the power of its wheels.

        Returns:
            (bool): True if the information was successfully sent to the
                MiniBot.

        Args:
            direction (Direction): Direction to move the MiniBot.
        """
        if direction is Direction.FORWARD:
            return self.__move_bot(self.max_motor_pow, self.max_motor_pow,
                                   self.max_motor_pow, self.max_motor_pow)
        elif direction is Direction.BACKWARD:
            return self.__move_bot(-self.max_motor_pow, -self.max_motor_pow,
                                   -self.max_motor_pow, -self.max_motor_pow)
        elif direction is Direction.RIGHT_FORWARD:
            return self.__move_bot(self.max_motor_pow, -self.max_motor_pow,
                                   self.max_motor_pow, -self.max_motor_pow)
        elif direction is Direction.LEFT_FORWARD:
            return self.__move_bot(-self.max_motor_pow, self.max_motor_pow,
                                   -self.max_motor_pow, self.max_motor_pow)
        else:
            # dir is Direction.STOP or None
            return self.__move_bot(0., 0., 0., 0.)

    def __move_bot(self, fl: float, fr: float, bl: float, br: float) -> bool:
        """
        Sends specified wheel power information to the MiniBot.

        Returns:
            (bool): True if the information was successfully sent to the
                MiniBot.

        Args:
            fl (float): `-100. <= fl <= 100.`. Front-left wheel's power.
            fr (float): `-100. <= fr <= 100.`. Front-right wheel's power.
            bl (float): `-100. <= bl <= 100.`. Back-left wheel's power.
            br (float): `-100. <= br <= 100.`. Back-right wheel's power.
        """
        return self.__assoc_vbot.get_command_center().set_wheel_power(fl, fr,
                                                                      bl, br)
